package leetcode

import (
	"bytes"
	"fmt"
	"path"
	"regexp"
	"strconv"
	"strings"

	"github.com/openset/leetcode/internal/client"
)

func GetTags() (tags []tagType) {
	data := fileGetContents("tag/tags.json")
	jsonDecode(data, &tags)
	tags = tagsUnique(tags)
	return
}

func SaveTags(tags []tagType) {
	ts := tagsUnique(append(GetTags(), tags...))
	filePutContents("tag/tags.json", jsonEncode(ts))
}

func tagsUnique(tags []tagType) []tagType {
	rs, top := make([]tagType, 0, len(tags)), 1
	var flag = make(map[string]int)
	for _, tag := range tags {
		i := flag[tag.Slug]
		if i == 0 {
			rs = append(rs, tag)
			flag[tag.Slug] = top
			top++
		} else {
			if tag.Name != "" {
				rs[i-1].Name = tag.Name
			}
			if tag.TranslatedName != "" {
				rs[i-1].TranslatedName = tag.TranslatedName
			}
		}
	}
	return rs
}

func GetTopicTag(slug string) (tt topicTagType) {
	jsonStr := `{
		"operationName": "getTopicTag",
		"variables": {
		"slug": "` + slug + `"
		},
		"query": "query getTopicTag($slug: String!) {\n  topicTag(slug: $slug) {\n    name\n    translatedName\n    questions {\n      status\n      questionId\n      questionFrontendId\n      title\n      titleSlug\n      translatedTitle\n      stats\n      difficulty\n      isPaidOnly\n      topicTags {\n        name\n        translatedName\n        slug\n        __typename\n      }\n      companyTags {\n        name\n        translatedName\n        slug\n        __typename\n      }\n      __typename\n    }\n    frequencies\n    __typename\n  }\n  favoritesLists {\n    publicFavorites {\n      ...favoriteFields\n      __typename\n    }\n    privateFavorites {\n      ...favoriteFields\n      __typename\n    }\n    __typename\n  }\n}\n\nfragment favoriteFields on FavoriteNode {\n  idHash\n  id\n  name\n  isPublicFavorite\n  viewCount\n  creator\n  isWatched\n  questions {\n    questionId\n    title\n    titleSlug\n    __typename\n  }\n  __typename\n}\n"
	}`
	filename := "topic_tag_" + strings.Replace(slug, "-", "_", -1) + ".json"
	graphQLRequest(filename, 7, jsonStr, &tt)
	return
}

type tagType struct {
	Name           string
	Slug           string
	TranslatedName string
}

type topicTagType struct {
	Errors []errorType `json:"errors"`
	Data   ttDataType  `json:"data"`
}

type ttDataType struct {
	TopicTag ttType `json:"topicTag"`
}

type ttType struct {
	Name           string           `json:"name"`
	TranslatedName string           `json:"translatedName"`
	Questions      []ttQuestionType `json:"questions"`
}

type ttQuestionType struct {
	QuestionId         string    `json:"questionId"`
	QuestionFrontendId string    `json:"questionFrontendId"`
	Title              string    `json:"title"`
	TitleSlug          string    `json:"titleSlug"`
	TranslatedTitle    string    `json:"translatedTitle"`
	TranslatedContent  string    `json:"translatedContent"`
	IsPaidOnly         paidType  `json:"isPaidOnly"`
	Difficulty         string    `json:"difficulty"`
	TopicTags          []tagType `json:"topicTags"`
}

func (question ttQuestionType) TagsStr() string {
	var buf bytes.Buffer
	format := "[[%s](https://github.com/openset/leetcode/tree/master/tag/%s/README.md)] "
	for _, tag := range question.TopicTags {
		buf.WriteString(fmt.Sprintf(format, tag.ShowName(), tag.Slug))
	}
	SaveTags(question.TopicTags)
	return string(buf.Bytes())
}

func (tag tagType) SaveContents() {
	questions := GetTopicTag(tag.Slug).Data.TopicTag.Questions
	var buf bytes.Buffer
	buf.WriteString("<!--|This file generated by command(leetcode tag); DO NOT EDIT.            |-->")
	buf.WriteString(authInfo)
	buf.WriteString(fmt.Sprintf("\n## %s\n\n", tag.ShowName()))
	buf.WriteString("| # | 题名 | 标签 | 难度 |\n")
	buf.WriteString("| :-: | - | - | :-: |\n")
	format := "| %s | [%s](https://github.com/openset/leetcode/tree/master/problems/%s)%s | %s | %s |\n"
	maxId := 0
	rows := make(map[int]string)
	for _, question := range questions {
		id, err := strconv.Atoi(question.QuestionFrontendId)
		checkErr(err)
		if question.TranslatedTitle == "" {
			question.TranslatedTitle = question.Title
		}
		rows[id] = fmt.Sprintf(format, question.QuestionFrontendId, question.TranslatedTitle, question.TitleSlug, question.IsPaidOnly.Str(), question.TagsStr(), question.Difficulty)
		if id > maxId {
			maxId = id
		}
	}
	for i := maxId; i > 0; i-- {
		if row, ok := rows[i]; ok {
			buf.WriteString(row)
		}
	}
	filename := path.Join("tag", tag.Slug, "README.md")
	filePutContents(filename, buf.Bytes())
}

func (tag tagType) ShowName() string {
	if tag.TranslatedName != "" {
		return tag.TranslatedName
	}
	return tag.Name
}

func init() {
	html := remember(problemsetAllFile, 7, func() []byte {
		return client.Get(problemsetAllUrl)
	})
	var tags []tagType
	reg := regexp.MustCompile(`href="/tag/(\S+?)/"`)
	for _, matches := range reg.FindAllStringSubmatch(string(html), -1) {
		if len(matches) >= 2 {
			tags = append(tags, tagType{Slug: matches[1]})
		}
	}
	SaveTags(tags)
}
